# See LICENSE.incore for details
metadata:
  all_regs: &all_regs "['x'+str(x) for x in range(0,32 if 'e' not in base_isa else 16)]"
  all_fregs: &all_fregs "['f'+str(x) for x in range(0,32 if 'e' not in base_isa else 16)]"
  all_regs_mx0: &all_regs_mx0 "['x'+str(x) for x in range(1,32 if 'e' not in base_isa else 16)]"
  c_regs: &c_regs "['x'+str(x) for x in range(8,16)]"

add:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val + rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
 

sub:
  stride: 1
  xlen: [32,64]
  std_op:
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  isa: I
  operation: 'hex((rs1_val - rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)


addw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend( (rs1_val & 0xFFFFFFFF) + (rs2_val & 0xFFFFFFFF) ,32))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

subw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend( (rs1_val & 0xFFFFFFFF) - (rs2_val & 0xFFFFFFFF) ,32))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

and:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val & rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

or:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val | rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

slt:
  rs1_op_data: *all_regs
  stride: 1
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(int(rs1_val < rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sltu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(int(rs1_val < rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

xor:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val ^ rs2_val) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sllw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((rs1_val << (rs2_val%32)) ,32))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

srlw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((rs1_val & 0xffffffff) >> (rs2_val%32), 32))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sraw:
  rs1_op_data: *all_regs
  stride: 1
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((sign_extend(rs1_val,32) >> ((rs2_val & 0xffffffff) %32))& 0xffffffff ,32))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sll:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val << (rs2_val%xlen)) & (2**(xlen)-1))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

srl:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val & (2**(xlen)-1)) >> (rs2_val%xlen))'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sra:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(rs1_val >> (rs2_val%xlen) )'
  formattype: 'rformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

addi:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val + imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

addiw:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend( (rs1_val & 0xFFFFFFFF) + (imm_val & 0xffffffff) , 32))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12,True)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

slti:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(int(rs1_val < imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12,True)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

sltiu:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(int(rs1_val < int(imm_val if imm_val&0x800 == 0 else imm_val + int("0x"+"".join("f"*int((xlen-12)/4)+"000"),16))) & (2**(xlen)-1))'
  rs1_val_data: 'gen_usign_dataset(xlen)+ gen_sp_dataset(xlen,False)'
  imm_val_data: 'gen_usign_dataset(12)+ gen_sp_dataset(12,False)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

andi:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val & imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

ori:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val | imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

xori:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val ^ imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_sign_dataset(12)+ gen_sp_dataset(12)'
  formattype: 'iformat'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

slli:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val << imm_val) & (2**(xlen)-1))'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

srli:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex((rs1_val & (2**(xlen)-1)) >> imm_val)'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

srai:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(rs1_val >> (imm_val))'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(ceil(log(xlen,2)))'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

slliw:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((rs1_val << imm_val) , 32))'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

srliw:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((rs1_val & 0xFFFFFFFF) >> imm_val , 32))'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

sraiw:
  stride: 1
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  operation: 'hex(sign_extend((sign_extend(rs1_val,32) >> ((imm_val & 0xfff) %32)) & 0xffffffff, 32))'
  formattype: 'iformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  imm_val_data: 'gen_usign_dataset(5)'
  template: |-
    
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

lui:
  stride: 1
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(sign_extend(imm_val << (12), 32))'
  formattype: 'uformat'
  imm_val_data: 'gen_usign_dataset(20)+ gen_sp_dataset(20,False)'
  template: |-
    
    // $comment
    // opcode: $inst ; dest:$rd; immval:$imm_val
    TEST_CASE($testreg, $rd, $correctval, $swreg, $offset, $inst $rd,$imm_val)

auipc:
  stride: 1
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  operation: 'hex(sign_extend(imm_val << (12) ,32))'
  formattype: 'uformat'
  imm_val_data: 'gen_usign_dataset(20)+ gen_sp_dataset(20, False)'
  template: |-

    // $comment
    // opcode: $inst ; dest:$rd; immval:$imm_val
    TEST_AUIPC($inst, $rd, $correctval, $imm_val, $swreg, $offset, $testreg)

beq:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

bge:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

bgeu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_usign_dataset(xlen)+ gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen)+ gen_sp_dataset(xlen,False)'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

blt:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen,True)'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

bltu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_usign_dataset(xlen)+ gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen)+ gen_sp_dataset(xlen,False)'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

bne:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'bformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen) '
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen) '
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(12)))'
  template: |-

    // $comment
    // opcode: $inst, op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_BRANCH_OP($inst, $testreg, $rs1, $rs2, $rs1_val, $rs2_val, $imm_val, $label, $swreg, $offset,$ea_align)

sd:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: I
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3,4,5,6,7]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align)

sw:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align)

sh:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align)

sb:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align)

ld:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  isa: I
  xlen: [64]
  std_op:
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3,4,5,6,7]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lwu:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  isa: I
  xlen: [64]
  std_op:
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lw:
  stride: 1
  rs1_op_data: *all_regs_mx0 
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lhu:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lh:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lbu:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

lb:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align)

jal:
  stride: 1
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'jformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'list(filter(lambda x: x%2==0,gen_sign_dataset(20)))'
  template: |-

    // $comment
    // opcode: jal; dest:$rd; immval:$imm_val; align:$ea_align
    TEST_JAL_OP($testreg, $rd, $imm_val, $label, $swreg, $offset,$ea_align)

jalr:
  stride: 1
  rs1_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-

    // $comment
    // opcode: jalr; op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align 
    TEST_JALR_OP($testreg, $rd, $rs1, $imm_val, $swreg, $offset,$ea_align)

mul:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex((rs1_val * rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

mulh:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(((rs1_val * rs2_val)>>xlen) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

mulhu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(((rs1_val * rs2_val)>>xlen) & (2**(xlen)-1))'
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

mulhsu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(((rs1_val * (rs2_val if rs2_val>=0 else int(hex((1<<xlen) + rs2_val),base=16)))>>xlen) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

div:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation:  'hex(int(abs(rs1_val)//abs(rs2_val))) if (rs1_val * rs2_val > 0) else hex(-int(abs(rs1_val)//abs(rs2_val))) if rs2_val != 0 else "0x"+("F"*int(xlen/4))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

divu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(int(rs1_val // rs2_val) & (2**(xlen)-1)) if rs2_val!=0 else "0x"+("F"*int(xlen/4))'
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

rem:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  #  operation: 'hex(rs1_val if rs2_val==0 or (rs1_val<rs2_val and rs2_val<0) else (rs1_val % rs2_val) & (2**(xlen)-1))'
  operation: 'hex(rs1_val) if rs2_val == 0 else hex(int(abs(rs1_val) % abs(rs2_val))) if rs1_val > 0 else hex(-int(abs(rs1_val) % abs(rs2_val)))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

remu:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(rs1_val) if rs2_val == 0 else hex(int(abs(rs1_val) % abs(rs2_val))) '
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

mulw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(sign_extend((rs1_val & 0xFFFFFFFF) * (rs2_val & 0xFFFFFFFF) ,32))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

divw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IM
  formattype: 'rformat'
  #  operation: 'hex(sign_extend(int((rs1_val & 0xFFFFFFFF) // (rs2_val & 0xFFFFFFFF)) ,32)) if (rs2_val&0xFFFFFFFF)!=0 else "0x"+("F"*int(xlen/4))'
  operation: 'hex(sign_extend(int(abs(sign_extend(rs1_val,32))//abs(sign_extend(rs2_val,32))),32)) if (sign_extend(rs1_val,32) * sign_extend(rs2_val,32) > 0) else hex(-int(abs(sign_extend(rs1_val,32))//abs(sign_extend(rs2_val, 32)))) if sign_extend(rs2_val,32) != 0 else "0x"+("F"*int(xlen/4))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

divuw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(sign_extend(int((rs1_val & 0xFFFFFFFF) // (rs2_val & 0xFFFFFFFF)) ,32)) if (rs2_val&0xFFFFFFFF)!=0 else "0x"+("F"*int(xlen/4))'
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

remw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IM
  formattype: 'rformat'
  #  operation: 'hex(sign_extend(((rs1_val & 0xFFFFFFFF) % (rs2_val & 0xFFFFFFFF)) , 32)) if (rs2_val&0xFFFFFFFF)!=0 else hex(rs1_val)'
  operation: 'hex(sign_extend(rs1_val,32)) if (rs2_val&0xffffffff) == 0 else hex(sign_extend(int(abs(sign_extend(rs1_val,32)) % abs(sign_extend(rs2_val,32))),32)) if sign_extend(rs1_val,32) > 0 else hex(-int(abs(sign_extend(rs1_val,32)) % abs(sign_extend(rs2_val,32))))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

remuw:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IM
  formattype: 'rformat'
  operation: 'hex(sign_extend((rs1_val & 0xFFFFFFFF) % (rs2_val & 0xFFFFFFFF) , 32)) if (rs2_val&0xFFFFFFFF)!=0 else hex(sign_extend(rs1_val,32))'
  rs1_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  rs2_val_data: 'gen_usign_dataset(xlen) + gen_sp_dataset(xlen,False)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.mv:
  stride: 1
  rs2_op_data: *all_regs_mx0
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cmvformat'
  operation: 'hex(rs2_val)'
  rs2_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op2:$rs2; dest:$rd; op2val:$rs2_val
    TEST_CMV_OP( $inst, $rd, $rs2, $correctval, $rs2_val, $swreg, $offset, $testreg)

c.add:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs_mx0
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex((rs1_val + rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen,True)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen,True)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.addw:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex(sign_extend((rs1_val + rs2_val) ,32))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.and:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex((rs1_val & rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.or:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex((rs1_val | rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.xor:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex((rs1_val ^ rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.sub:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex((rs1_val - rs2_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.subw:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'crformat'
  operation: 'hex(sign_extend((rs1_val & 0xFFFFFFFF) - (rs2_val & 0xFFFFFFFF) ,32))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val
    TEST_CR_OP( $inst, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

c.andi:
  stride: 1
  rs1_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  operation: 'hex((rs1_val & imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_sp_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(6)+gen_sp_dataset(6)'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; immval:$imm_val
    TEST_CI_OP( $inst, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.nop:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cjformat'
  imm_val_data: 'gen_sign_dataset(6)'
  template: |-
  
    // $comment
    // opcode:$inst; immval:$imm_val
    TEST_CNOP_OP($inst, $testreg, $imm_val, $swreg, $offset)

c.addi:
  stride: 1
  rd_op_data: *all_regs_mx0
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation: 'hex((rs1_val + imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(6) + gen_sp_dataset(6)'
  template: |-

    // $comment
    // opcode:$inst; op1:$rd; dest:$rd op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rd, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.addiw:
  stride: 1
  rd_op_data: *all_regs_mx0
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation: 'hex(sign_extend(((rs1_val & 0xFFFFFFFF) + (imm_val & 0xffffffff)) , 32))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(6) + gen_sp_dataset(6)'
  template: |-

    // $comment
    // opcode:$inst; op1:$rd; dest:$rd op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rd, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.addi16sp:
  stride: 1
  rd_op_data: "['x2']"
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation: 'hex((rs1_val + imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'list(filter( lambda x: x!=0 , [ 16*x for x in gen_sign_dataset(6)])) + [496]'
  template: |-

    // $comment
    // opcode:$inst; op1:x2; dest:x2 op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, x2, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.addi4spn:
  stride: 1
  rd_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciwformat'
  operation: 'hex(imm_val)'
  imm_val_data: 'list(filter( lambda x: x!=0 , [ 4*x for x in gen_usign_dataset(8)]))'
  template: |-

    // $comment
    // opcode:$inst; dest:$rd; immval:$imm_val
    TEST_CADDI4SPN_OP( $inst, $rd, $correctval, $imm_val, $swreg, $offset, $testreg)

c.slli:
  stride: 1
  rd_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation: 'hex((rs1_val << imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: x!=0, gen_usign_dataset(ceil(log(xlen,2)))))'
  template: |-

    // $comment
    // opcode:$inst; op1:$rd; dest:$rd op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rd, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.srli:
  stride: 1
  rs1_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  operation: 'hex(((rs1_val & (2**(xlen)-1)) >> imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: x!=0, gen_usign_dataset(ceil(log(xlen,2)))))'
  template: |-

    // $comment
    // opcode:$inst; op1:$rs1; dest:$rs1 op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.srai:
  stride: 1
  rs1_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  operation: 'hex(rs1_val >> (imm_val) & (2**(xlen)-1))'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: x!=0, gen_usign_dataset(ceil(log(xlen,2)))))'
  template: |-

    // $comment
    // opcode:$inst; op1:$rs1; dest:$rs1 op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.li:
  stride: 1
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation : 'hex(sign_extend(imm_val,6))'
  imm_val_data: 'gen_sign_dataset(6)'
  template: |-

    // $comment
    // opcode:$inst; dest:$rd; immval:$imm_val
    TEST_CASE($testreg, $rd, $correctval, $swreg, $offset, $inst $rd, $imm_val;)

c.lui:
  stride: 1
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  operation: 'hex(sign_extend(imm_val << 12,32))'
  rs1_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: x!=0 ,gen_usign_dataset(6)))'
  template: |-

    // $comment
    // opcode:$inst; op1:$rd; dest:$rd op1val:$rs1_val; immval:$imm_val
    TEST_CI_OP( $inst, $rd, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

c.sw:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'csformat'
  rs1_val_data: '[0]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: '[x*4 for x in gen_usign_dataset(5)]'
  template: |-

    // $comment
    // opcode:$inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,0)

c.sd:
  stride: 1
  rs1_op_data: *c_regs
  rs2_op_data: *c_regs
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'csformat'
  rs1_val_data: '[0]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: '[x*8 for x in gen_usign_dataset(5)]'
  template: |-

    // $comment
    // opcode:$inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val
    TEST_STORE($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,0)

c.ld:
  stride: 1
  rs1_op_data: *c_regs
  rd_op_data: *c_regs 
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'clformat'
  rs1_val_data: '[0]'
  imm_val_data: '[x*8 for x in gen_usign_dataset(5)]'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; dest:$rd; op1val:$rs1_val; immval:$imm_val
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$rs1_val)

c.lw:
  stride: 1
  rs1_op_data: *c_regs
  rd_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'clformat'
  rs1_val_data: '[0]'
  imm_val_data: '[x*4 for x in gen_usign_dataset(5)]'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; dest:$rd; immval:$imm_val
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,0)

c.lwsp:
  stride: 1
  rd_op_data: *all_regs_mx0
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  imm_val_data: '[x*4 for x in gen_usign_dataset(6)]'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; dest:$rd; immval:$imm_val
    TEST_LOAD($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,0)

c.ldsp:
  stride: 1
  rd_op_data: *all_regs_mx0
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'ciformat'
  imm_val_data: '[x*8 for x in gen_usign_dataset(6)]'
  template: |-

    // $comment
    // opcode: $inst; op1:x2; dest:$rd; immval:$imm_val
    TEST_LOAD($swreg,$testreg,$index,x2,$rd,$imm_val,$offset,$inst,0)

c.swsp:
  stride: 1
  rs2_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cssformat'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: '[x*4 for x in gen_usign_dataset(6)]'
  template: |-

    // $comment
    // opcode:$inst; op1:x2; op2:$rs2; op2val:$rs2_val; immval:$imm_val
    TEST_STORE($swreg,$testreg,$index,x2,$rs2,$rs2_val,$imm_val,$offset,$inst,0)

c.sdsp:
  stride: 1
  rs2_op_data: *all_regs
  xlen: [64]
  std_op:
  isa: IC
  formattype: 'cssformat'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: '[x*8 for x in gen_usign_dataset(6)]'
  template: |-

    // $comment
    // opcode:$inst; op1:x2; op2:$rs2; op2val:$rs2_val; immval:$imm_val
    TEST_STORE($swreg,$testreg,$index,x2,$rs2,$rs2_val,$imm_val,$offset,$inst,0)

c.beqz:
  stride: 1
  rs1_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  rs1_val_data: 'gen_sign_dataset(xlen) + gen_sp_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: (x >=4 and x<250) or (x<=-4 and x>=-250),[x*2 for x in gen_sign_dataset(8)]))'
  template: |-

    // $comment
    // opcode:$inst; op1:$rs1; op1val:$rs1_val; immval:$imm_val
    TEST_CBRANCH_OP($inst, $testreg, $rs1, $rs1_val, $imm_val, $label, $swreg, $offset)

c.bnez:
  stride: 1
  rs1_op_data: *c_regs
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  rs1_val_data: 'gen_sign_dataset(xlen)+ gen_sp_dataset(xlen)'
  imm_val_data: 'list(filter(lambda x: (x >=4 and x<250) if x>0 else (x<=-4 and x>=-250),[x*2 for x in gen_sign_dataset(8)]))'
  template: |-

    // $comment
    // opcode: $inst; op1:$rs1; op1val:$rs1_val; immval:$imm_val
    TEST_CBRANCH_OP($inst, $testreg, $rs1, $rs1_val, $imm_val, $label, $swreg, $offset)

c.j:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cjformat'
  imm_val_data: 'list(filter(lambda x: (x >=4 and x<2030) if x>0 else (x<=-4 and x> -2030 ),[x*2 for x in gen_sign_dataset(11)]))'
  template: |-

    // $comment
    // opcode:$inst; immval:$imm_val
    TEST_CJ_OP($inst, $testreg, $imm_val, $label, $swreg, $offset)

c.jal:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'cbformat'
  imm_val_data: 'list(filter(lambda x: (x >=4 and x<2030) if x>0 else (x<=-4 and x> -2030 ),[x*2 for x in gen_sign_dataset(11)]))'
  template: |-

    // $comment
    // opcode:$inst; immval:$imm_val
    TEST_CJAL_OP($inst, $testreg, $imm_val, $label, $swreg, $offset)

c.jr:
  stride: 1
  rs1_op_data: *all_regs_mx0
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  template: |-

    // $comment
    // opcode: c.jr; op1:$rs1
    TEST_CJR_OP($testreg, $rs1, $swreg, $offset)

c.jalr:
  stride: 1
  rs1_op_data: *all_regs_mx0
  xlen: [32,64]
  std_op:
  isa: IC
  formattype: 'crformat'
  template: |-

    // $comment
    // opcode:c.jalr; op1:$rs1
    TEST_CJALR_OP($testreg, $rs1, $swreg, $offset)

fadd.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fadd.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fsub.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsub.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmul.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmul.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fdiv.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fdiv.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsqrt.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPSR_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsqrt.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPSR_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmadd.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmadd.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmsub.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmsub.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fnmadd.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fnmadd.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fnmsub.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fnmsub.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fr4format'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rs3_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; op3:$rs3; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; op3val:$rs3_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; testreg:$testreg
    TEST_FPR4_OP($inst, $rd, $rs1, $rs2, $rs3, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fsgnj.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsgnj.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsgnjn.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsgnjn.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsgnjx.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fsgnjx.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmin.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmin.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmax.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmax.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPRR_OP($inst, $rd, $rs1, $rs2, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
feq.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
feq.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
flt.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
flt.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fle.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fle.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'frformat'
  rs1_op_data: *all_fregs
  rs2_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val; op2val:$rs2_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; correctval:$correctval; testreg:$testreg
    TEST_FCMP_OP($inst, $rd, $rs1, $rs2, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmv.w.x:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmv.x.w:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.w.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.w.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.wu.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fcvt.wu.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.l.d:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fcvt.lu.d:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fmv.x.d:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.s.d:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPSR_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.d.s:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_fregs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPSR_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)  
    
fcvt.s.w:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fcvt.s.wu:
  stride: 2
  xlen: [32,64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
 
fcvt.d.w:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fcvt.d.wu:
  stride: 2
  xlen: [32,64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.d.l:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fcvt.d.lu:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fmv.d.x:
  stride: 2
  xlen: [64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fclass.s:
  stride: 2
  xlen: [32,64]
  isa: IF
  std_op:
  flen: [32]
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
   
fclass.d:
  stride: 2
  xlen: [32, 64]
  isa: IFD
  flen: [64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)

fsw:
  stride: 2
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_fregs
  xlen: [32,64]
  isa: IF
  std_op:
  flen: [32]
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-
    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align; flagreg:$flagreg;
    TEST_STORE_F($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align,$flagreg)
    
flw:
  stride: 2
  rs1_op_data: *all_regs_mx0 
  rd_op_data: *all_fregs
  xlen: [32,64]
  std_op:
  isa: IF
  flen: [32]
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-
    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align; flagreg:$flag_reg
    TEST_LOAD_F($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align,$flagreg)
    
fsd:
  stride: 2
  rs1_op_data: *all_regs_mx0
  rs2_op_data: *all_fregs
  std_op:
  xlen: [32,64]
  isa: IFD
  flen: [64]
  formattype: 'sformat'
  ea_align_data: '[0,1,2,3]'
  rs2_val_data: 'gen_sign_dataset(xlen)'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-
    // $comment
    // opcode: $inst; op1:$rs1; op2:$rs2; op2val:$rs2_val; immval:$imm_val; align:$ea_align; flagreg:$flagreg;
    TEST_STORE_F($swreg,$testreg,$index,$rs1,$rs2,$rs2_val,$imm_val,$offset,$inst,$ea_align,$flagreg)
    
fld:
  stride: 2
  rs1_op_data: *all_regs_mx0 
  rd_op_data: *all_fregs
  xlen: [32,64]
  std_op:
  isa: IFD
  flen: [64]
  formattype: 'iformat'
  ea_align_data: '[0,1,2,3]'
  imm_val_data: 'gen_sign_dataset(12)'
  template: |-
    // $comment
    // opcode:$inst op1:$rs1; dest:$rd; immval:$imm_val; align:$ea_align; flagreg:$flag_reg
    TEST_LOAD_F($swreg,$testreg,$index,$rs1,$rd,$imm_val,$offset,$inst,$ea_align,$flagreg)
    
fcvt.l.s:
  stride: 2
  xlen: [64]
  std_op:
  isa: IF
  flen: [32,64]
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.lu.s:
  stride: 2
  xlen: [64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_fregs
  rd_op_data: *all_regs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPID_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
    
fcvt.s.l:
  stride: 2
  xlen: [64]
  isa: IF
  std_op:
  flen: [32,64]
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
 
fcvt.s.lu:
  stride: 2
  xlen: [64]
  isa: IF
  flen: [32,64]
  std_op:
  formattype: 'fsrformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_fregs
  template: |-
    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val; valaddr_reg:$valaddr_reg; val_offset:$val_offset; rmval:$rm_val; correctval:$correctval; testreg:$testreg
    TEST_FPIO_OP($inst, $rd, $rs1, $rm_val, $correctval, $valaddr_reg, $val_offset, $flagreg, $swreg, $offset, $testreg)
        
aes32dsi:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes32dsmi:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes32esi:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes32esmi:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
sm4ed:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I_Zks
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
sm4ks:
  stride: 1
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  xlen: [32,64]
  std_op:
  isa: I_Zks
  formattype: 'bsformat'
  template: |-

    // $comment
    // opcode: $inst; rd:$rd; op1:$rs1; op2:$rs2; op1val:$rs1_val; op2val:$rs2_val; immval:$imm_val
    TEST_RI_OP($inst, $rd, $rs1, $rs2, $imm_val, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sha256sig0:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha256sig0 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
sha256sig1:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha256sig1 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
sha256sum0:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha256sum0 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

sha256sum1:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha256sum1 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

sm3p0:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I_Zks
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sm3p0 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

sm3p1:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I_Zks
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sm3p1 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

sha512sig0h:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

sha512sig0l:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)    
    
sha512sig1h:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)    

sha512sig1l:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
sha512sum0r:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
sha512sum1r:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

ror:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
rol:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
rori:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'iformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)
    
rev.b:
  stride: 1
  xlen: [32,64]
  std_op: grevi
  isa: I
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    grevi $rd, $rs1, 7
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
rev8:
  stride: 1
  xlen: [32,64]
  std_op: grevi
  isa: I
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    grevi $rd, $rs1, ($xlen-8)
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
zip:
  stride: 1
  xlen: [32, 64]
  std_op: shfli
  isa: I
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    shfli $rd, $rs1, 15
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

unzip:
  stride: 1
  xlen: [32, 64]
  std_op: unshfli
  isa: I
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    unshfli $rd, $rs1, 15
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

clmul:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

clmulh:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

andn:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
orn:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
xnor:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
pack:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

packu:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

packh:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

xperm.n:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

xperm.b:
  stride: 1
  xlen: [32,64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

aes64ds:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes64dsm:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes64es:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes64esm:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
aes64ks1i:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'iformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)
    
aes64ks2:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  rs2_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
sha512sig0:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha512sig0 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

sha512sig1:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha512sig1 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
sha512sum0:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha512sum0 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
sha512sum1:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    sha512sum1 $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
aes64im:
  stride: 1
  xlen: [64]
  std_op:
  isa: IK
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  rs1_val_data: 'gen_sign_dataset(xlen)+gen_usign_dataset(xlen)'
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    aes64im $rd, $rs1
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)
    
rorw:
  stride: 1
  xlen: [64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
rolw:
  stride: 1
  xlen: [64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
    
roriw:
  stride: 1
  xlen: [64]
  std_op:
  isa: I
  formattype: 'iformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;  immval:$imm_val
    TEST_IMM_OP( $inst, $rd, $rs1, $correctval, $rs1_val, $imm_val, $swreg, $offset, $testreg)

rev8.w:
  stride: 1
  xlen: [64]
  std_op: grevi
  isa: I
  formattype: 'kformat'
  rs1_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; dest:$rd; op1val:$rs1_val;
    li $rs1, $rs1_val
    grevi  $rd, $rs1, 24
    sw $rd, $offset($swreg)
    RVMODEL_IO_ASSERT_GPR_EQ($testreg, $rd, $correctval)

packw:
  stride: 1
  xlen: [64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)

packuw:
  stride: 1
  xlen: [64]
  std_op:
  isa: I
  formattype: 'rformat'
  rs1_op_data: *all_regs
  rs2_op_data: *all_regs
  rd_op_data: *all_regs
  template: |-

    // $comment
    // opcode: $inst ; op1:$rs1; op2:$rs2; dest:$rd; op1val:$rs1_val;  op2val:$rs2_val
    TEST_RR_OP($inst, $rd, $rs1, $rs2, $correctval, $rs1_val, $rs2_val, $swreg, $offset, $testreg)
