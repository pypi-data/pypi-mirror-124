{"version":3,"file":"lib_index_js.6f5994679b93f4c13935.js","mappings":";;;;;;;;;;;;;AAAO;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BuD;AACZ;AACY;AAChD,gCAAgC,gEAAgB;AACvD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,kCAAkC,qDAAM;AACxC;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAoD;AAChF;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,gEAAgB;AACxD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,iCAAiC,qDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAgC;AAC5C,SAAS;AACT;AACA;AACA,QAAQ,qFAAmC;AAC3C;AACA;AACA;AACA;AACA;AACO,kCAAkC,gEAAgB;AACzD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,qCAAqC,qDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,gEAAgB;AAC3D,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gEAAgB;AACvD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gEAAgB;AAClD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,gEAAgB;AACrD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,gEAAgB;AACpD,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChW+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClCwD;AACd;AACsF;AAC+C;AACxI;AACvC;AACO,kDAAkD,oDAAK;AAC9D;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,aAAa,uBAAuB;AACpC,mDAAmD,qCAAqC;AACxF;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,qCAAqC,sDAAiB;AACtD;AACA;AACA,SAAS;AACT,qCAAqC,sDAAiB;AACtD;AACA;AACA,SAAS;AACT,sCAAsC,uDAAkB;AACxD;AACA;AACA,SAAS;AACT,kCAAkC,mDAAc;AAChD;AACA;AACA,SAAS;AACT,uCAAuC,wDAAmB;AAC1D;AACA;AACA,SAAS;AACT,yCAAyC,0DAAqB;AAC9D;AACA;AACA,SAAS;AACT,gCAAgC,iDAAY;AAC5C;AACA;AACA,SAAS;AACT,mCAAmC,oDAAe;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,0IAAmC;AACpE;AACA,6CAA6C,WAAW;AACxD,2BAA2B,oDAAU;AACrC,8FAA8F,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,8BAA8B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF,+FAA+F,uBAAuB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/config_supplicant.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/events.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/index.js"],"sourcesContent":["export class ConfigSupplicant {\n    constructor({ paths, config }) {\n        this.enable = this.enable.bind(this);\n        this.disable = this.disable.bind(this);\n        this.init = this.init.bind(this);\n        this._config = config;\n        this._paths = paths;\n    }\n    init() {\n        try {\n            let state = this._paths.reduce((previousValue, currentValue) => {\n                return previousValue[currentValue];\n            }, this._config);\n            //  We need to know the value assigned to the reference path (i.e., paths); \n            //  hence, drill into the arbitrary config object in order to obtain the value.    \n            if (state === false) {\n                this.disable();\n            }\n            else if (state === true) {\n                this.enable();\n            }\n            else {\n                throw new Error();\n            }\n        }\n        catch (e) {\n            this.enable();\n            //  The default is for all events to be enabled; hence, we don't need to log anything here.\n        }\n    }\n}\n","import { NotebookActions } from \"@jupyterlab/notebook\";\nimport { Signal } from '@lumino/signaling';\nimport { ConfigSupplicant } from \"./config_supplicant\";\nexport class NotebookSaveEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookSaveEvent\", \"enable\"],\n            config\n        });\n        this._notebookSaved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(context, saveState) {\n        let cell;\n        let cells;\n        let index;\n        if (saveState.match(\"completed\")) {\n            cells = [];\n            for (index = 0; index < this._notebookPanel.content.widgets.length; index++) {\n                cell = this._notebookPanel.content.widgets[index];\n                if (this._notebookPanel.content.isSelectedOrActive(cell)) {\n                    cells.push({ id: cell.model.id, index });\n                }\n            }\n            this._notebookSaved.emit({\n                event_name: \"save_notebook\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    enable() {\n        (async () => {\n            await this._notebookPanel.revealed;\n            this._notebookPanel.context.saveState.connect(this.event, this);\n        })();\n    }\n    disable() {\n        this._notebookPanel.context.saveState.disconnect(this.event, this);\n    }\n    get notebookSaved() {\n        return this._notebookSaved;\n    }\n}\nexport class CellExecutionEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellExecutionEvent\", \"enable\"],\n            config\n        });\n        this._cellExecuted = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(_, args) {\n        if (args.notebook.model === this._notebook.model) {\n            let cells = [\n                {\n                    id: args.cell.model.id,\n                    index: this._notebook.widgets.findIndex((value) => value == args.cell)\n                }\n            ];\n            this._cellExecuted.emit({\n                event_name: \"cell_executed\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    enable() {\n        (async () => {\n            await this._notebookPanel.revealed;\n            NotebookActions.executed.connect(this.event, this);\n        })();\n    }\n    disable() {\n        NotebookActions.executed.disconnect(this.event, this);\n    }\n    get cellExecuted() {\n        return this._cellExecuted;\n    }\n}\nexport class NotebookScrollEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookScrollEvent\", \"enable\"],\n            config\n        });\n        this._notebookScrolled = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this._timeout = 0;\n        this.event = this.event.bind(this);\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(e) {\n        e.stopPropagation();\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(() => {\n            let cells = [];\n            let cell;\n            let index;\n            let id;\n            for (index = 0; index < this._notebook.widgets.length; index++) {\n                cell = this._notebook.widgets[index];\n                let cellTop = cell.node.offsetTop;\n                let cellBottom = cell.node.offsetTop + cell.node.offsetHeight;\n                let viewTop = this._notebook.node.scrollTop;\n                let viewBottom = this._notebook.node.scrollTop + this._notebook.node.clientHeight;\n                if (cellTop > viewBottom || cellBottom < viewTop) {\n                    continue;\n                }\n                id = cell.model.id;\n                cells.push({ id, index });\n            }\n            this._notebookScrolled.emit({\n                event_name: \"scroll\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }, 1000);\n    }\n    enable() {\n        (async () => {\n            await this._notebookPanel.revealed;\n            this._notebook.node.addEventListener(\"scroll\", this.event, false);\n        })();\n    }\n    disable() {\n        this._notebook.node.removeEventListener(\"scroll\", this.event, false);\n    }\n    get notebookScrolled() {\n        return this._notebookScrolled;\n    }\n}\nexport class ActiveCellChangeEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/ActiveCellChangeEvent\", \"enable\"],\n            config\n        });\n        this._activeCellChanged = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(send, args) {\n        let cells = [\n            {\n                id: args.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == args)\n            }\n        ];\n        this._activeCellChanged.emit({\n            event_name: \"active_cell_changed\",\n            cells: cells,\n            notebookPanel: this._notebookPanel\n        });\n    }\n    enable() {\n        (async () => {\n            await this._notebookPanel.revealed;\n            this._notebook.activeCellChanged.connect(this.event, this);\n        })();\n    }\n    disable() {\n        this._notebook.activeCellChanged.disconnect(this.event, this);\n    }\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n}\nexport class NotebookOpenEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/NotebookOpenEvent\", \"enable\"],\n            config\n        });\n        this._notebookOpened = new Signal(this);\n        this._once = false;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event() {\n        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));\n        this._notebookOpened.emit({\n            event_name: \"open_notebook\",\n            cells: cells,\n            notebookPanel: this._notebookPanel\n        });\n        this._once = true;\n    }\n    enable() {\n        if (!this._once) {\n            (async () => {\n                await this._notebookPanel.revealed;\n                this.event();\n            })();\n        }\n    }\n    disable() {\n        return;\n    }\n    get notebookOpened() {\n        return this._notebookOpened;\n    }\n}\nexport class CellAddEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellAddEvent\", \"enable\"],\n            config\n        });\n        this._cellAdded = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(sender, args) {\n        if (args.type == \"add\") {\n            let cells = [{ id: args.newValues[0].id, index: args.newIndex }];\n            this._cellAdded.emit({\n                event_name: \"add_cell\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    enable() {\n        (async () => {\n            var _a;\n            await this._notebookPanel.revealed;\n            (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);\n        })();\n    }\n    disable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);\n    }\n    get cellAdded() {\n        return this._cellAdded;\n    }\n}\nexport class CellRemoveEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellRemoveEvent\", \"enable\"],\n            config\n        });\n        this._cellRemoved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(sender, args) {\n        if (args.type == \"remove\") {\n            let cells = [{ id: args.oldValues[0].id, index: args.oldIndex }];\n            this._cellRemoved.emit({\n                event_name: \"remove_cell\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    enable() {\n        (async () => {\n            var _a;\n            await this._notebookPanel.revealed;\n            (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.event, this);\n        })();\n    }\n    disable() {\n        var _a;\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this.event, this);\n    }\n    get cellRemoved() {\n        return this._cellRemoved;\n    }\n}\nexport class CellErrorEvent extends ConfigSupplicant {\n    constructor({ notebookPanel, config }) {\n        super({\n            paths: [\"mentoracademy.org/schemas/events/1.0.0/CellErrorEvent\", \"enable\"],\n            config\n        });\n        this._cellErrored = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.dispose, this);\n        this.init();\n    }\n    dispose() {\n        Signal.disconnectAll(this);\n    }\n    event(_, args) {\n        var _a;\n        if (args.header.msg_type == \"error\") {\n            let cells = [\n                {\n                    id: (_a = this._notebookPanel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.id,\n                    index: this._notebookPanel.content.activeCellIndex\n                }\n            ];\n            this._cellErrored.emit({\n                event_name: \"cell_errored\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    enable() {\n        (async () => {\n            await this._notebookPanel.revealed;\n            this._notebookPanel.sessionContext.iopubMessage.connect(this.event, this);\n        })();\n    }\n    disable() {\n        this._notebookPanel.sessionContext.iopubMessage.disconnect(this.event, this);\n    }\n    get cellErrored() {\n        return this._cellErrored;\n    }\n}\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-library', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { Token } from '@lumino/coreutils';\nimport { IETCJupyterLabNotebookStateProvider } from \"@educational-technology-collective/etc_jupyterlab_notebook_state_provider\";\nimport { NotebookOpenEvent, NotebookSaveEvent, CellExecutionEvent, NotebookScrollEvent, ActiveCellChangeEvent, CellAddEvent, CellRemoveEvent, CellErrorEvent } from \"./events\";\nimport { requestAPI } from \"./handler\";\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_library:plugin';\nexport const IETCJupyterLabTelemetryLibraryFactory = new Token(PLUGIN_ID);\nclass ETCJupyterLabTelemetryLibraryFactory {\n    constructor({ config }) {\n        this._config = config;\n    }\n    create({ notebookPanel, config }) {\n        return new ETCJupyterLabTelemetryLibrary({ notebookPanel, config: this._config });\n    }\n}\nexport class ETCJupyterLabTelemetryLibrary {\n    constructor({ notebookPanel, config }) {\n        this.notebookOpenEvent = new NotebookOpenEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookSaveEvent = new NotebookSaveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellExecutionEvent = new CellExecutionEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellErrorEvent = new CellErrorEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookScrollEvent = new NotebookScrollEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.activeCellChangeEvent = new ActiveCellChangeEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellAddEvent = new CellAddEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellRemoveEvent = new CellRemoveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n    }\n}\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_extension extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IETCJupyterLabTelemetryLibraryFactory,\n    requires: [INotebookTracker, IETCJupyterLabNotebookStateProvider],\n    activate: async (app, notebookTracker, etcJupyterLabNotebookStateProvider) => {\n        console.log(`The JupyterLab plugin ${PLUGIN_ID} is activated!`);\n        let config = await requestAPI(\"config\");\n        let etcJupyterLabTelemetryLibraryFactory = new ETCJupyterLabTelemetryLibraryFactory({ config });\n        // // TEST\n        // class MessageAdapter {\n        //   constructor() { }\n        //   log(sender: any, args: any) {\n        //     let notebookPanel = args.notebookPanel;\n        //     delete args.notebookPanel;\n        //     let notebookState = etcJupyterLabNotebookStateProvider.getNotebookState({ notebookPanel: notebookPanel })\n        //     let data = {\n        //       ...args, ...notebookState\n        //     }\n        //     console.log(\"etc_jupyterlab_telemetry_extension\", data);\n        //   }\n        // }\n        // let messageAdapter = new MessageAdapter();\n        // notebookTracker.widgetAdded.connect(async (sender: INotebookTracker, notebookPanel: NotebookPanel) => {\n        //   etcJupyterLabNotebookStateProvider.addNotebookPanel({ notebookPanel });\n        //   let etcJupyterLabTelemetryLibrary = etcJupyterLabTelemetryLibraryFactory.create({ notebookPanel, config });\n        //   etcJupyterLabTelemetryLibrary.notebookOpenEvent.notebookOpened.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookSaveEvent.notebookSaved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.activeCellChangeEvent.activeCellChanged.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellAddEvent.cellAdded.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellRemoveEvent.cellRemoved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookScrollEvent.notebookScrolled.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellExecutionEvent.cellExecuted.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellErrorEvent.cellErrored.connect(messageAdapter.log);\n        // });\n        // // TEST\n        return etcJupyterLabTelemetryLibraryFactory;\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}